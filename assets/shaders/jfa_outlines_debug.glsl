#[compute]
#version 450

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(rgba16, set = 0, binding = 0) uniform restrict readonly image2D input_image;
layout(rgba16, set = 1, binding = 0) uniform restrict readonly image2D original_image;
layout(rgba16, set = 2, binding = 0) uniform restrict writeonly image2D output_image;
layout(std430, set = 3, binding = 0) buffer restrict readonly OutlinesSizeBuffer { int size; } osb;

float custom_distance(vec2 pixel_size, vec2 from, vec2 to) {
	return sqrt(pow((from.x - to.x) / pixel_size.x, 2) + pow((from.y - to.y) / pixel_size.y, 2));
}

void main() {
	ivec2 current_position = ivec2(gl_GlobalInvocationID.xy);
	vec4 current_pixel = imageLoad(input_image, current_position);

	// The "rough" outline generated by the Jump Flood Algorithm contains all the pixels of the desired outline + some more
	// If the current pixel is not a seed, then it can't be part of the outline
	if (current_pixel.x == 0.0f && current_pixel.y == 0.0f) {
		imageStore(output_image, current_position, vec4(0.0f));
		// imageStore(output_image, current_position, vec4(0.0f, 0.0f, 1.0f, 1.0f));
		return;
	}

	ivec2 image_size = imageSize(input_image);
	vec2 normalized_current_position = vec2(current_position) / vec2(image_size);
	vec2 pixel_size = vec2(1.0f) / vec2(image_size);
	float distance_to_seed = custom_distance(pixel_size, normalized_current_position, current_pixel.xy);
	float outlines_size = float(osb.size);

	if (normalized_current_position != current_pixel.xy) {
		imageStore(output_image, current_position, vec4(1.0f));
		return;
	}

	imageStore(output_image, current_position, vec4(0.0f));
	return;

	// The current pixel is outside the outline range
	if (distance_to_seed > outlines_size) {
		imageStore(output_image, current_position, vec4(0.0f));
		// imageStore(output_image, current_position, vec4(1.0f, 0.0f, 0.0f, 1.0f));
		return;
	}

	ivec2 current_seed_position = ivec2(current_pixel.xy * pixel_size);
	vec4 original_pixel = imageLoad(original_image, current_seed_position);

	// The current pixel is on the edge of the outline, outer side
	if (distance_to_seed > outlines_size - 1.0f) {
		float smoothing = 1.0f - (distance_to_seed - (outlines_size - 1.0f));
		imageStore(output_image, current_position, vec4(original_pixel.xyz, smoothing));
		// imageStore(output_image, current_position, vec4(1.0f, 1.0f, 0.0f, 1.0f));
		return;
	}

	// The current pixel is part of the object to outline
	if (distance_to_seed < 0.25f) {
		imageStore(output_image, current_position, vec4(0.0f));
		// imageStore(output_image, current_position, vec4(0.0f, 1.0f, 0.0f, 1.0f));
		return;
	}

	// The current pixel is on the edge of the outline, inner side
	if (distance_to_seed < 1.0f) {
		float smoothing = distance_to_seed;
		imageStore(output_image, current_position, vec4(original_pixel.xyz, smoothing));
		// imageStore(output_image, current_position, vec4(0.0f, 1.0f, 1.0f, 1.0f));
		return;
	}

	// The current pixel is part of the outline
	imageStore(output_image, current_position, vec4(original_pixel.xyz, 1.0f));
}
